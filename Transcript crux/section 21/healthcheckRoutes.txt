ðŸš€ Starting Real Implementation â€“ Health Check API

Now that all preparation is done:
- Project structure ready
- Express configured
- Database connected
- Standard API response & error classes created

We can finally start building based on the PRD.

---

ðŸ§  Why Health Check First?

In almost every production application, there is a Health Check API.

Purpose:
- Cloud providers (AWS, GCP, etc.) continuously check
  whether your server is alive and responding.
- Used for monitoring system status.

PRD Endpoint:
GET /api/v1/healthcheck

Expected:
- Status 200
- Message like â€œServer is runningâ€

---

ðŸ— Architecture Flow

Controller â†’ Routes â†’ app.js

1) Controller
   - Contains actual logic
   - Sends response

2) Routes
   - Defines path
   - Connects route to controller

3) app.js
   - Imports route
   - Prefixes it with base path
   - Registers middleware

---

ðŸ“ Step 1: Create Controller

File:
src/controllers/healthcheck.controller.js

Import APIResponse:
import APIResponse from "../utils/api-response.js";

Create method:

const healthcheck = (req, res) => {
  try {
    return res.status(200).json(
      new APIResponse(
        200,
        { message: "Server is running" },
        "Success"
      )
    );
  } catch (error) {
    // Will improve later using higher-order function
  }
};

export { healthcheck };

What happens here:
- Status code = 200
- Data = { message: "Server is running" }
- Message = "Success"
- Success flag automatically true (because < 400)

---

ðŸ“ Step 2: Create Route

File:
src/routes/healthcheck.routes.js

Boilerplate:

import { Router } from "express";
const router = Router();

Import controller:
import { healthcheck } from "../controllers/healthcheck.controller.js";

Define route:
router.route("/").get(healthcheck);

export default router;

Important:
Route here is "/"
Base path will be added inside app.js

---

ðŸ“ Step 3: Register Route in app.js

Import route:
import healthcheckRouter from "./routes/healthcheck.routes.js";

Register route:
app.use("/api/v1/healthcheck", healthcheckRouter);

What happens internally:

Client hits:
GET /api/v1/healthcheck

app.js:
â†’ routes to healthcheckRouter

healthcheck.routes.js:
â†’ "/" route

Final effective endpoint:
GET /api/v1/healthcheck

---

ðŸ§ª Testing in Postman

Request:
GET http://localhost:8000/api/v1/healthcheck

Response:
{
  "statusCode": 200,
  "data": {
    "message": "Server is running"
  },
  "message": "Success",
  "success": true
}

Everything is standardized via APIResponse class.

---

ðŸ§  Important Understanding

Why not write full path inside routes?

Because:
- app.js prefixes base path
- routes file stays clean
- Easier to version APIs later

Example:
If tomorrow you change:
"/api/v2/healthcheck"

Only app.js changes.
Routes file remains untouched.

---

ðŸ“Œ Current Flow Summary

Client â†’ app.js â†’ route file â†’ controller â†’ APIResponse â†’ Client

Clean separation.
Scalable structure.
Production-ready design.

---

âš  Next Improvement

Using try-catch in every controller is repetitive.

Next step:
Use Higher Order Function (async handler)
to remove repetitive try-catch blocks.

---

ðŸ”¥ One-Line Takeaway

Health check route is the first real production endpoint,
and it validates that your backend architecture is correctly wired.
